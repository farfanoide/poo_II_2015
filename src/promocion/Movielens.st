Object subclass: #MovieDecorator	instanceVariableNames: 'decorated data invalidAttrs updatedAt retriever'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-MovieDecorators'!!MovieDecorator commentStamp: 'IvanKarl 5/27/2015 01:49' prior: 0!Abstract Movie Decorator, should not be instatiated.!!MovieDecorator methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 23:31'!initialize	invalidAttrs := Set with: 'N/A'.	data := Dictionary new.	retriever := self retrieverClass new! !!MovieDecorator methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 18:23'!mustUpdateData	^ [ (updatedAt - DateAndTime now) minutes > 10 ] on: Error do: [ true ]! !!MovieDecorator methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 18:24'!retrieveData	updatedAt := DateAndTime now.	^ retriever retrieveDataFor: decorated imdbID	"^ Dictionary new  ^ self subclassResponsibility"! !!MovieDecorator methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/28/2015 00:13'!doesNotUnderstand: aMessage	self mustUpdateData		ifTrue: [ data := self retrieveData ].	^ (self hasAttribute: (aMessage selector asString))		ifTrue: [ data at: (aMessage asString) ]		ifFalse: [ decorated perform: aMessage selector withArguments: aMessage arguments ]! !!MovieDecorator methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/28/2015 00:14'!hasAttribute: aName	^ data includesKey: aName! !!MovieDecorator methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 00:40'!decorate: anObject	decorated := anObject! !!MovieDecorator methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 01:36'!data: aDictionary	data := aDictionary ! !!MovieDecorator methodsFor: 'as yet unclassified' stamp: 'IvanKarl 6/8/2015 02:24'!retrieverClass	^ (((self className substrings: 'Decorator') first ), 'Retriever') asSymbol asClass! !MovieDecorator subclass: #DbpediaDecorator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-MovieDecorators'!!DbpediaDecorator commentStamp: 'IvanKarl 5/27/2015 01:50' prior: 0!Concrete DBPedia Decorator.!MovieDecorator subclass: #OmdbDecorator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-MovieDecorators'!!OmdbDecorator commentStamp: 'IvanKarl 5/27/2015 01:50' prior: 0!Concrete OMDB Decorator.!MovieDecorator subclass: #ThemoviedbDecorator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-MovieDecorators'!!ThemoviedbDecorator commentStamp: 'IvanKarl 5/27/2015 01:50' prior: 0!Concrete TheMovieDB Decorator.!MovieDecorator subclass: #ImdbDecorator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-MovieDecorators'!!ImdbDecorator commentStamp: 'IvanKarl 5/27/2015 01:50' prior: 0!Concrete IMDB Decorator.!TestCase subclass: #MovielensTesting	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Tests'!!MovielensTesting methodsFor: 'as yet unclassified' stamp: 'IvanKarl 6/8/2015 02:26'!resetMovielens	Movielens reset.	Movielens default		importUsersFromFile: 'u.user.test';		importItemsFromFile: 'u.item.test';		importRatingsFromFile: 'u.data.test';		importConnectionsFromFile: 'u.connection.test'.			Movielens default movies do: [ :movie | movie year: movie title asInteger ].	Movielens default syncNewAssociations! !MovielensTesting subclass: #MovielensTest	instanceVariableNames: 'movielens'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Tests'!!MovielensTest methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 18:29'!setUpself resetMovielens! !!MovielensTest methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/25/2015 21:25'!testImportDataself assert: Movielens default users size = 10.self assert: Movielens default movies size = 20.self assert: (Movielens default userForId: 1 ) friends size = 5.self assert: (Movielens default userForId: 2 ) friends size = 3.self assert: (Movielens default userForId: 3 ) friends size = 5. ! !!MovielensTest methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/25/2015 21:36'!testGenres	| genres |	genres := Set		withAll:			#('Comedy' 'Western' 'War' 'Animation' 'Sci-Fi' 'Childrens' 'Action' 'Romance' 'Documentary' 'Adventure' 'Drama' 'Thriller').	self should: [ MovielensStatistics default genres = genres ]! !!MovielensTest methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/25/2015 21:40'!testMoviesByGenre	| movies |	movies := OrderedCollection with: (Movielens default movieForID: 1).	self should: [ (MovielensStatistics default moviesByGenre: 'Animation') = movies ]! !MovielensTesting subclass: #MovieDecoratorsTest	instanceVariableNames: 'movielens'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Tests'!!MovieDecoratorsTest methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/28/2015 00:36'!testUndecoratedMovie	| movie |	movie := Movielens default movies first.	movie		title: 'fake title';		year: 1934.	self		assert: movie title = 'fake title';		assert: movie year = 1934;		assert: movie class = Movie! !!MovieDecoratorsTest methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 18:31'!setUp	self resetMovielens! !!MovieDecoratorsTest methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/28/2015 00:36'!testDecoratedMovie	| movie |	Movielens default enableDecorationWith: 'themoviedbTest,dbpediaTest,imdbTest'.	movie := Movielens default movies first.	self		assert: movie class = ThemoviedbTestDecorator;		assert: movie title = 'responded from dbpedia';		assert: movie posterUrl = 'responded from imdb';		assert: movie director = 'responded from themoviedb'! !Retriever subclass: #TestRetriever	instanceVariableNames: 'parser'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Tests'!!TestRetriever commentStamp: 'IvanKarl 6/8/2015 02:26' prior: 0!Retriever Mock!MovieDecorator subclass: #MovieDecoratorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Tests'!!MovieDecoratorTest commentStamp: 'IvanKarl 6/8/2015 02:27' prior: 0!MovieDecorator Mock!!MovieDecoratorTest methodsFor: 'as yet unclassified' stamp: 'IvanKarl 6/8/2015 02:25'!retrieverClass	^ TestRetriever! !MovieDecoratorTest subclass: #ImdbTestDecorator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Tests'!!ImdbTestDecorator commentStamp: 'IvanKarl 6/8/2015 02:27' prior: 0!ImdbDecorator Mock!!ImdbTestDecorator methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 23:46'!retrieveData	^ Dictionary newFromPairs: (Array with: 'posterUrl' with: 'responded from imdb')! !MovieDecoratorTest subclass: #DbpediaTestDecorator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Tests'!!DbpediaTestDecorator commentStamp: 'IvanKarl 6/8/2015 02:27' prior: 0!dbpediaDecorator Mock!!DbpediaTestDecorator methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 23:45'!retrieveData	^ Dictionary newFromPairs: (Array with: 'title' with: 'responded from dbpedia')! !MovieDecoratorTest subclass: #ThemoviedbTestDecorator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Tests'!!ThemoviedbTestDecorator commentStamp: 'IvanKarl 6/8/2015 02:26' prior: 0!ThemoviedbDecorator Mock!!ThemoviedbTestDecorator methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 23:47'!retrieveData	^ Dictionary newFromPairs: (Array with: 'director' with: 'responded from themoviedb')! !Object subclass: #MovielensReader	instanceVariableNames: 'filename elements'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Readers'!!MovielensReader commentStamp: 'DiegoTorres 4/20/2015 11:35' prior: 0!A MovielensReader is a generic file reader for the Movielens project. See subclasses for concrete readers."To load the dump"Movielens reset.Movielens default importItemsFromFile: 'u.item'. Movielens default importUsersFromFile: 'u.user'.Movielens default importRatingsFromFile: 'u.data'.Movielens default importConnectionsFromFile: 'u.connection.csv'.!!MovielensReader methodsFor: 'accessing' stamp: 'JulianGrigera 4/16/2015 14:31'!read	| readStream |	readStream := filename asFileReference readStream.	[readStream atEnd] whileFalse: [self addElementFrom: readStream]! !!MovielensReader methodsFor: 'accessing' stamp: 'JulianGrigera 4/14/2015 22:16'!elements	^elements! !!MovielensReader methodsFor: 'accessing' stamp: 'JulianGrigera 4/14/2015 22:16'!addElementFrom: readStream	self subclassResponsibility! !!MovielensReader methodsFor: 'accessing' stamp: 'JulianGrigera 4/14/2015 22:16'!filename: aString	filename := aString.	filename asFileReference exists ifFalse: [self error: 'File does not exist']! !MovielensReader subclass: #MovielensConnectionReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Readers'!!MovielensConnectionReader methodsFor: 'initialize-release' stamp: 'DiegoTorres 4/20/2015 11:34'!addElementFrom: readStream	|  user friend  |		user:= Movielens default userForId: (readStream upTo: $|) asNumber  .	friend:= Movielens default userForId: (readStream upTo: (Character lf) ) asNumber.	user addFriend: friend.	! !!MovielensConnectionReader methodsFor: 'initialize-release' stamp: 'DiegoTorres 4/20/2015 11:18'!initializesuper initialize .elements:= OrderedCollection new.! !MovielensReader subclass: #MovielensItemReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Readers'!!MovielensItemReader methodsFor: 'as yet unclassified' stamp: 'DiegoTorres 4/20/2015 01:21'!addGenre: pipedString for: aMovie	| genre genreValue selection |	genre := #('unknown' 'Action' 'Adventure' 'Animation' 'Childrens' 'Comedy' 'Crime' 'Documentary' 'Drama' 'Fantasy' 'Film-Noir' 'Horror' 'Musical' 'Mystery' 'Romance' 'Sci-Fi' 'Thriller' 'War' 'Western').	genreValue:= OrderedCollection new.		selection:= pipedString asOrderedCollection select:[:e| e isDigit].	1 to:19 do:[:mark| ((selection at:mark) = $1) ifTrue: [  genreValue add: (genre at:mark) ]].	aMovie genre: genreValue .	! !!MovielensItemReader methodsFor: 'as yet unclassified' stamp: 'ArturoZambrano 4/29/2015 13:33'!addElementFrom: readStream	|  movie  |	movie := Movie new.	movie		localID: (readStream upTo: $|) asNumber;		title: (readStream upTo: $|);		releasedDate: (readStream upTo: $|);		videoRelease: (readStream upTo: $|);		imdbID: (readStream upTo: $|).	self addGenre: (readStream upTo: (Character lf) ) for: movie. 		elements at: movie localID put: movie! !!MovielensItemReader methodsFor: 'as yet unclassified' stamp: 'DiegoTorres 4/19/2015 23:26'!initializesuper initialize.elements := Dictionary new.! !MovielensReader subclass: #MovielensDataReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Readers'!!MovielensDataReader commentStamp: 'JulianGrigera 4/14/2015 22:28' prior: 0!| reader |reader := MovielensDataReader new.reader filename: '/Users/yulius123/Desktop/ml-100k-objetos-2/u.data'.reader read.reader inspect. !!MovielensDataReader methodsFor: 'initialize' stamp: 'JulianGrigera 4/16/2015 14:32'!initialize	super initialize.	elements := OrderedCollection new.! !!MovielensDataReader methodsFor: 'accessing' stamp: 'DiegoTorres 4/20/2015 01:39'!addElementFrom: readStream	| user rating movieId|	user := Movielens default userForId: (readStream upTo: Character tab) asNumber.	rating := Rating new.	rating		user: user.		movieId:= (readStream upTo: Character tab) asNumber.	rating 		movie: (Movielens default movieForID: movieId);		rating: (readStream upTo: Character tab) asNumber;		timestamp:  (readStream upTo:Character lf ).	elements add: rating! !MovielensReader subclass: #MovielensUsersReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Readers'!!MovielensUsersReader commentStamp: 'JulianGrigera 4/14/2015 22:11' prior: 0!| reader |reader := MovielensUsersReader new.reader filename: '/Users/yulius123/Desktop/ml-100k-objetos-2/u.user'.reader read.reader inspect. !!MovielensUsersReader methodsFor: 'accessing' stamp: 'JulianGrigera 4/16/2015 14:21'!addElementFrom: readStream	| user |	user := User new.	user		id: (readStream upTo: $|) asNumber;		age: (readStream upTo: $|) asNumber;		gender: ((readStream upTo: $|) = 'M' ifTrue: ['Male'] ifFalse: ['Female']);		occupation: (readStream upTo: $|);		zipCode: (readStream upTo: $|);		firstName: (readStream upTo: $|);		lastName: (readStream upTo: Character cr).	elements at: user id put: user! !!MovielensUsersReader methodsFor: 'initialize' stamp: 'JulianGrigera 4/16/2015 14:31'!initialize	super initialize.	elements := Dictionary new.! !Object subclass: #Retriever	instanceVariableNames: 'url'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Retrievers'!!Retriever commentStamp: 'IvanKarl 5/27/2015 01:51' prior: 0!Template Class for movie info retrievers.!!Retriever methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 17:42'!fetchDataFor: anId	^ self subclassResponsibility! !!Retriever methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 01:52'!retrieveDataFor: anId	^ [ (self fetchDataFor: anId) asDictionary ]		on: Error		do: [ Dictionary new ]! !Retriever subclass: #DbpediaRetriever	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Retrievers'!!DbpediaRetriever commentStamp: 'IvanKarl 5/27/2015 01:51' prior: 0!Concrete DBPedia Retriever.!Retriever subclass: #FileRetriever	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Retrievers'!!FileRetriever commentStamp: 'IvanKarl 5/27/2015 01:51' prior: 0!Concrete File Retriever.!!FileRetriever methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 01:39'!fetchDataFor: anId	^ (Movielens readDataFromFile: self url) detect: [ :movie | movie imdbID = anId ]! !Retriever subclass: #OmdbRetriever	instanceVariableNames: 'parser'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Retrievers'!!OmdbRetriever commentStamp: 'IvanKarl 5/27/2015 01:51' prior: 0!Concrete OMDB Retriever.!!OmdbRetriever methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 01:23'!fetchDataFor: anId	| document tag |	document := self parser perseURL: self url , anId asString.	tag := document allElementsNamed: 'movie'.	^ tag first attributes! !!OmdbRetriever methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 01:24'!initialize	url := 'http://www.omdbapi.com/?r=XML&i='.	parser := XMLDOMParser! !Retriever subclass: #ThemoviedbRetriever	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Retrievers'!!ThemoviedbRetriever commentStamp: 'IvanKarl 5/27/2015 01:51' prior: 0!Concrete DBPedia Retriever.!Retriever subclass: #ImdbRetriever	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Retrievers'!!ImdbRetriever commentStamp: 'IvanKarl 5/27/2015 01:51' prior: 0!Concrete IMDB Retriever.!Object subclass: #Movielens	instanceVariableNames: 'users ratings movies strategy'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Core'!!Movielens commentStamp: 'ArturoZambrano 4/23/2015 21:58' prior: 0!A Movielens is the entry point to the Movielens project.Instance Variables	users:		<OrderedCollection>users	- All users of MovielensMovielens reset.Movielens default importItemsFromFile: 'u.item'. Movielens default importUsersFromFile: 'u.user'.Movielens default importRatingsFromFile: 'u.data'.Movielens default importConnectionsFromFile: 'u.connection.csv'.!!Movielens methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 17:54'!strategy	^ strategy! !!Movielens methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 17:46'!getRawMovies	^ movies! !!Movielens methodsFor: 'initialization' stamp: 'IvanKarl 5/27/2015 18:34'!initialize	super initialize.	self users: OrderedCollection new.	self ratings: OrderedCollection new.	self movies: OrderedCollection new.	self strategy: (UndecoratedMovie with: self).! !!Movielens methodsFor: 'private' stamp: 'IvanKarl 5/27/2015 17:54'!strategy: aStrategy	strategy := aStrategy! !!Movielens methodsFor: 'private' stamp: 'DiegoTorres 4/20/2015 00:34'!movies: aCollection	movies := aCollection! !!Movielens methodsFor: 'private' stamp: 'IvanKarl 5/27/2015 17:47'!users: aCollection	users := aCollection! !!Movielens methodsFor: 'private' stamp: 'JulianGrigera 4/16/2015 14:29'!ratings: aCollection 	ratings := aCollection ! !!Movielens methodsFor: 'helpers' stamp: 'IvanKarl 5/27/2015 01:40'!readItemsFromFile: aFile  | reader |  reader := MovielensItemReader new.  reader filename: self baseDirectoryName, aFile.  ^ reader read elements! !!Movielens methodsFor: 'accesing' stamp: 'IvanKarl 5/27/2015 17:47'!users	^ users! !!Movielens methodsFor: 'accesing' stamp: 'IvanKarl 5/27/2015 17:47'!userForId: id	^ self users detect: [ :user | user id = id ]! !!Movielens methodsFor: 'accesing' stamp: 'IvanKarl 5/27/2015 17:51'!ratings	^ ratings! !!Movielens methodsFor: 'accesing' stamp: 'IvanKarl 5/27/2015 17:45'!movies	^ self strategy movies! !!Movielens methodsFor: 'accesing' stamp: 'IvanKarl 5/27/2015 17:47'!movieForID: id	^ self movies detect: [ :movie | movie localID = id ]! !!Movielens methodsFor: 'importing' stamp: 'DiegoTorres 4/20/2015 11:26'!importConnectionsFromFile: aString	| reader |	reader := MovielensConnectionReader new.	reader filename: self baseDirectoryName, aString.	reader read.! !!Movielens methodsFor: 'importing' stamp: 'IvanKarl 5/27/2015 16:50'!baseDirectoryName	^ FileSystem workingDirectory fullName , '/'! !!Movielens methodsFor: 'importing' stamp: 'IvanKarl 5/27/2015 17:53'!importAllData	self		importItemsFromFile: 'u.item';		importUsersFromFile: 'u.user';		importRatingsFromFile: 'u.data';		importConnectionsFromFile: 'u.connection.csv';		syncNewAssociations ! !!Movielens methodsFor: 'importing' stamp: 'IvanKarl 5/27/2015 18:26'!disableDecoration	strategy := UndecoratedMovie new! !!Movielens methodsFor: 'importing' stamp: 'IvanKarl 5/27/2015 23:49'!enableDecorationWith: aString	strategy := DecoratedMovie with: self withDecorators: aString! !!Movielens methodsFor: 'importing' stamp: 'JulianGrigera 4/14/2015 22:27'!importUsersFromFile: aString	| reader |	reader := MovielensUsersReader new.	reader filename: self baseDirectoryName, aString.	reader read.	self users addAll: reader elements! !!Movielens methodsFor: 'importing' stamp: 'IvanKarl 5/27/2015 17:47'!importRatingsFromFile: aString	| reader |	reader := MovielensDataReader new.	reader filename: self baseDirectoryName , aString.	reader read.	self ratings addAll: reader elements! !!Movielens methodsFor: 'importing' stamp: 'IvanKarl 5/27/2015 01:42'!importItemsFromFile: aString	self movies addAll: (self readItemsFromFile: aString)! !!Movielens methodsFor: 'importing' stamp: 'IvanKarl 5/25/2015 09:40'!syncNewAssociations	self ratings		do: [ :rating | 			rating user addRating: rating.			rating movie addRating: rating ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Movielens class	instanceVariableNames: 'instance'!!Movielens class methodsFor: 'singleton' stamp: 'JulianGrigera 4/16/2015 14:20'!default	^instance ifNil: [ instance := self new ]! !!Movielens class methodsFor: 'singleton' stamp: 'JulianGrigera 4/16/2015 14:28'!reset	instance := nil! !Object subclass: #Movie	instanceVariableNames: 'title year rated releasedDate runtime genre director writer actors plot posterURL imdbRating imdbVotes localID imdbID type videoRelease ratings state'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Core'!!Movie commentStamp: '<historical>' prior: 0!IMDBMovie modela una pelicula con todos los datos que se pueden obtener desde IMDB.Instance Variables	actors	<String>	description of actors	director	<String>	description of director	genre	<String>	description of genre	imdbID	<String>	description of imdbID	imdbRating	<String>	description of imdbRating	imdbVotes	<String>	description of imdbVotes	plot	<String>	description of plot	posterURL	<String>	description of posterURL	rated	<String>	description of rated	releasedDate	<String>	description of releasedDate	runtime	<String>	description of runtime	title	<String>	description of title	type	<String>	description of type	writer	<String>	description of writer	year	<String>	description of year!!Movie methodsFor: 'printing' stamp: 'ArturoZambrano 4/29/2015 13:19'!printOn: aStreamaStream nextPutAll: title; nextPutAll:' imdbID: '; nextPutAll: imdbID printString.! !!Movie methodsFor: 'initialize-release' stamp: 'IvanKarl 5/27/2015 04:11'!initialize	super initialize.	title := 'N/A'.	year := 'N/A'.	rated := 'N/A'.	releasedDate := 'N/A'.	runtime := 'N/A'.	genre := 'N/A'.	director := 'N/A'.	writer := 'N/A'.	actors := 'N/A'.	plot := 'N/A'.	posterURL := 'N/A'.	imdbRating := 'N/A'.	imdbVotes := 'N/A'.	imdbID := 'N/A'.	type := 'N/A'.	videoRelease :='N/A'.	ratings:=Set new.	state := UndecoratedMovie with: self.	^ self! !!Movie methodsFor: 'accessing' stamp: 'IvanKarl 5/27/2015 18:36'!title^ title! !!Movie methodsFor: 'accessing' stamp: 'IvanKarl 5/25/2015 10:54'!ratings	^ ratings! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!imdbVotes: anObject	imdbVotes := anObject! !!Movie methodsFor: 'accessing' stamp: 'DiegoTorres 4/19/2015 23:57'!videoRelease: aDatevideoRelease:=aDate.! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!type: anObject	type := anObject! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!director: anObject	director := anObject! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!releasedDate	^releasedDate! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!genre	^genre! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!actors	^actors! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!director	^director! !!Movie methodsFor: 'accessing' stamp: 'IvanKarl 5/28/2015 00:33'!year^ year! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!plot: anObject	plot := anObject! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!posterURL: anObject	posterURL := anObject! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!runtime	^runtime! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!imdbRating: anObject	imdbRating := anObject! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!writer: anObject	writer := anObject! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!imdbRating	^imdbRating! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!imdbID: anObject	imdbID := anObject! !!Movie methodsFor: 'accessing' stamp: 'IvanKarl 5/27/2015 04:08'!doesNotUnderstand: aMessage	^ ((Set		withAll:			#('actors' 'director' 'genre' 'imdbID' 'imdbRating' 'imdbVotes' 'plot' 'posterURL' 'rated' 'releasedDate' 'runtime' 'title' 'type' 'writer' 'year'))		includes: aMessage selector asString)		ifTrue: [ state perform: aMessage selector withArguments: aMessage arguments ]		ifFalse: [ super doesNotUnderstand: aMessage ]! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!releasedDate: anObject	releasedDate := anObject! !!Movie methodsFor: 'accessing' stamp: 'Casco 4/28/2015 02:06'!imdbURL	^ imdbID notEmpty		ifTrue: [ 'http://www.imdb.com/title/' , imdbID ]		ifFalse: [ nil ]! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!imdbVotes	^imdbVotes! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!rated: anObject	rated := anObject! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!genre: anObject	genre := anObject! !!Movie methodsFor: 'accessing' stamp: 'IvanKarl 5/27/2015 18:36'!title: aString	title := aString! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!runtime: anObject	runtime := anObject! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!imdbID	^imdbID! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!plot	^plot! !!Movie methodsFor: 'accessing' stamp: 'IvanKarl 5/26/2015 01:59'!averageRating	^ [((ratings inject: 0 into: [ :sum :rating | sum + rating rating ]) / ratings size) asFloat] value! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!year: anObject	year := anObject! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!type	^type! !!Movie methodsFor: 'accessing' stamp: 'IvanKarl 5/25/2015 09:40'!addRating: aRating	ratings add: aRating! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!posterURL	^posterURL! !!Movie methodsFor: 'accessing' stamp: 'Casco 4/28/2015 02:01'!localID: anObject	localID := anObject! !!Movie methodsFor: 'accessing' stamp: 'Casco 4/28/2015 02:01'!localID	^localID! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!writer	^writer! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!actors: anObject	actors := anObject! !!Movie methodsFor: 'accessing' stamp: 'DiegoTorres 4/19/2015 23:57'!videoRelease^videoRelease! !!Movie methodsFor: 'accessing' stamp: ' 15/4/15 09:59'!rated	^rated! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Movie class	instanceVariableNames: ''!!Movie class methodsFor: 'instance creation' stamp: ' 15/4/15 09:59'!new	"Answer a newly created and initialized instance."	^super new initialize! !Object subclass: #Rating	instanceVariableNames: 'user movie rating timestamp'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Core'!!Rating commentStamp: 'IvanKarl 5/25/2015 09:33' prior: 0!a Rating!!Rating methodsFor: 'accessing' stamp: 'JulianGrigera 4/16/2015 14:19'!rating	^ rating! !!Rating methodsFor: 'accessing' stamp: 'DiegoTorres 4/20/2015 01:46'!movie^movie! !!Rating methodsFor: 'accessing' stamp: 'DiegoTorres 4/20/2015 01:46'!movie: aMovie^movie:= aMovie! !!Rating methodsFor: 'accessing' stamp: 'JulianGrigera 4/16/2015 14:19'!timestamp	^ timestamp! !!Rating methodsFor: 'accessing' stamp: 'JulianGrigera 4/16/2015 14:19'!user: anObject	user := anObject! !!Rating methodsFor: 'accessing' stamp: 'JulianGrigera 4/16/2015 14:19'!user	^ user! !!Rating methodsFor: 'accessing' stamp: 'JulianGrigera 4/16/2015 14:19'!timestamp: anObject	timestamp := anObject! !!Rating methodsFor: 'accessing' stamp: 'JulianGrigera 4/16/2015 14:19'!rating: anObject	rating := anObject! !Object subclass: #User	instanceVariableNames: 'id firstName lastName age gender occupation zipCode friends ratings'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Core'!!User commentStamp: '<historical>' prior: 0!See the comment in MovielensusersReader for an example of using this class!!User methodsFor: 'as yet unclassified' stamp: 'DiegoTorres 4/20/2015 11:23'!addFriend: aFriend	friends add: aFriend! !!User methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/25/2015 21:13'!initialize	super initialize.	friends := Set new.	ratings := Set new.! !!User methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/23/2015 19:32'!addRating: aRating	ratings add: aRating! !!User methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/25/2015 21:23'!friends	^ friends! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!age: anObject	age := anObject! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!id: anObject	id := anObject! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!lastName: anObject	lastName := anObject! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!id	^id! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!occupation: anObject	occupation := anObject! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!occupation	^occupation! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!firstName	^firstName! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!zipCode	^zipCode! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!gender	^gender! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!age	^age! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!gender: anObject	gender := anObject! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!zipCode: anObject	zipCode := anObject! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!lastName	^lastName! !!User methodsFor: 'accessing' stamp: 'IvanKarl 5/25/2015 10:54'!ratings	^ ratings! !!User methodsFor: 'accessing' stamp: ' 14/4/15 21:59'!firstName: anObject	firstName := anObject! !Object subclass: #OMDBMovieRetriever	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Core'!!OMDBMovieRetriever commentStamp: '<historical>' prior: 0!IMDBMovieRetriever sirve para traer los datos que IMDB tiene de una pelicula.Se le puede pasar la URL de la pelicula, o el ID.Si no la encuentra, devuelve una pelicula con todos sus datos en N/A.REQUIERE EL PARCEL HTTP (que esta en la secci√≥n Networking del parcel manager).Ejemplo:| retriever movie |retriever := IMDBMovieRetriever new.movie := retriever  retrieveMovieFromURL: 'http://us.imdb.com/M/title-exact?Toy%20Story%20(1995)'.movie inspect. !!OMDBMovieRetriever methodsFor: 'private' stamp: 'ArturoZambrano 5/4/2015 16:45'!retrieveMovieAttributesOf: id	| url document tagMovie tag |		[url := 'http://www.omdbapi.com/?r=XML&i=' , id asString.	document := XMLDOMParser parseURL: url.	tag := document allElementsNamed: 'movie'.	tag isEmpty		ifFalse: 			[tagMovie := tag at: 1.			^tagMovie attributes]]			on: Error			do: [^OrderedCollection new]! !Object subclass: #MovielensStatistics	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-Core'!!MovielensStatistics commentStamp: 'IvanKarl 5/25/2015 10:12' prior: 0!Statistics Class !!MovielensStatistics methodsFor: 'helpers' stamp: 'IvanKarl 5/25/2015 12:03'!moviesWithRating	^ self movies select: [ :movie | movie ratings size > 0 ]! !!MovielensStatistics methodsFor: 'helpers' stamp: 'IvanKarl 5/25/2015 10:38'!averageRatingForGenre: aGenre	| movs |	movs := self moviesByGenre: aGenre.	^ (movs inject: 0 into: [ :sum :movie | sum + movie averageRating ]) / movs size! !!MovielensStatistics methodsFor: 'helpers' stamp: 'IvanKarl 5/25/2015 10:51'!ratedMovies	^ self movies asSortedCollection: [ :ma :mb | ma averageRating > mb averageRating ]! !!MovielensStatistics methodsFor: 'helpers' stamp: 'IvanKarl 5/25/2015 10:39'!ratedGenres	^ self genres asSortedCollection: [ :ga :gb | (self averageRatingForGenre: ga) > (self averageRatingForGenre: gb) ]! !!MovielensStatistics methodsFor: 'helpers' stamp: 'IvanKarl 5/25/2015 10:53'!mostRatedMovies	^ self movies asSortedCollection: [ :ma :mb | ma ratings size > mb ratings size ]! !!MovielensStatistics methodsFor: 'helpers' stamp: 'IvanKarl 5/25/2015 12:12'!moviesWithRatingAndYear	^ self movies select: [ :movie | (movie ratings size > 0) & (movie year asInteger = nil) not ]! !!MovielensStatistics methodsFor: 'accessing' stamp: 'IvanKarl 5/25/2015 10:16'!users	^ self dataHolder users! !!MovielensStatistics methodsFor: 'accessing' stamp: 'IvanKarl 5/25/2015 10:16'!ratings	^ self dataHolder ratings! !!MovielensStatistics methodsFor: 'accessing' stamp: 'IvanKarl 5/25/2015 10:15'!dataHolder	^ Movielens default! !!MovielensStatistics methodsFor: 'accessing' stamp: 'IvanKarl 5/25/2015 10:16'!movies	^ self dataHolder movies! !!MovielensStatistics methodsFor: 'accessing' stamp: 'IvanKarl 5/25/2015 10:29'!moviesByGenre: aGenre	^ self dataHolder movies select: [ :movie | movie genre anySatisfy: [ :genre | genre = aGenre ] ]! !!MovielensStatistics methodsFor: 'accessing' stamp: 'IvanKarl 5/25/2015 10:25'!genres	^ self dataHolder movies flatCollect: [ :movie| movie genre ] as: Set! !!MovielensStatistics methodsFor: 'statistics' stamp: 'IvanKarl 5/25/2015 11:03'!recommendMoviesForUser: aUser amount: anAmount	^ (self recommendMoviesForUser: aUser) collect: [ :movie| movie ] from: 1 to: anAmount! !!MovielensStatistics methodsFor: 'statistics' stamp: 'IvanKarl 5/25/2015 10:39'!bestRatedGenre	^ self ratedGenres first! !!MovielensStatistics methodsFor: 'statistics' stamp: 'IvanKarl 5/25/2015 10:53'!topTenMostRatedMovies	^ self mostRatedMovies collect: [ :movie | movie ] from: 1 to: 10! !!MovielensStatistics methodsFor: 'statistics' stamp: 'IvanKarl 5/25/2015 11:02'!recommendMoviesForUser: aUser	| movs |	movs := aUser friends		flatCollect: [ :aFriend | (aUser ratings select: [ :aRating | aRating rating > 4 ]) collect: [ :raiting | raiting movie ] ]		as: Bag.	^ (movs select: [ :movie | (self movies occurrencesOf: movie) > (aUser friends size / 2) ])		asSortedCollection: [ :ma :mb | ma averageRating > mb averageRating ]! !!MovielensStatistics methodsFor: 'statistics' stamp: 'IvanKarl 5/26/2015 01:44'!topTenRatedMovies	^ (Array new: 10) addAll: (self ratedMovies collect: [ :movie | movie ] from: 1 to: 10)! !!MovielensStatistics methodsFor: 'statistics' stamp: 'IvanKarl 5/26/2015 01:45'!yearWithMostMoviesRated	| years |	years := self moviesWithRatingAndYear collect: [ :movie | movie year ].	^ [ (years asSortedCollection: [ :ya :yb | (years occurrencesOf: ya) > (years occurrencesOf: yb) ]) first ]		on: SubscriptOutOfBounds		do: [ 'nothing here' ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MovielensStatistics class	instanceVariableNames: 'instance'!!MovielensStatistics class methodsFor: 'singleton' stamp: 'IvanKarl 5/25/2015 10:13'!default	^instance ifNil: [ instance := self new ]! !!MovielensStatistics class methodsFor: 'singleton' stamp: 'IvanKarl 5/25/2015 10:13'!reset	instance := nil! !Object subclass: #MovieStrategy	instanceVariableNames: 'context'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-MovieStrategy'!!MovieStrategy commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State the name of the class with one line description: For example, I'm xxx the root of the hierarchy of visitor objects.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	movie:		<Object>    Implementation Points!!MovieStrategy methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 17:55'!movies	^ self context getRawMovies! !!MovieStrategy methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 18:35'!context	^ context! !!MovieStrategy methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 17:37'!context: aContext	context := aContext! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MovieStrategy class	instanceVariableNames: ''!!MovieStrategy class methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 17:37'!with: aContext	^ super new context: aContext! !MovieStrategy subclass: #DecoratedMovie	instanceVariableNames: 'decorators'	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-MovieStrategy'!!DecoratedMovie commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State the name of the class with one line description: For example, I'm xxx the root of the hierarchy of visitor objects.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	decorator:		<Object>    Implementation Points!!DecoratedMovie methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 17:27'!decorators	^ decorators! !!DecoratedMovie methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 17:21'!decorators: aString	decorators := aString! !!DecoratedMovie methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 17:27'!instatiateDecorators	^ ((self decorators substrings: ',')		collect: [ :sub | (sub capitalized , 'Decorator') asSymbol asClass new ]		as: OrderedCollection) reversed! !!DecoratedMovie methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 17:30'!movies	^ super movies collect: [ :movie | self decorate: movie ]! !!DecoratedMovie methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 17:32'!decorate: aMovie	^ self instatiateDecorators inject: aMovie into: [ :movie :decorator | decorator decorate: movie ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DecoratedMovie class	instanceVariableNames: ''!!DecoratedMovie class methodsFor: 'as yet unclassified' stamp: 'IvanKarl 5/27/2015 17:56'!with: aContext withDecorators: aString	^ (super with: aContext) decorators: aString! !MovieStrategy subclass: #UndecoratedMovie	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Movielens-MovieStrategy'!!UndecoratedMovie commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State the name of the class with one line description: For example, I'm xxx the root of the hierarchy of visitor objects.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!